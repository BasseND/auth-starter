input {
  beats {
    port => 5044
  }
  
  # Lecture directe des fichiers de logs
  file {
    path => "/logs/*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => "json"
    tags => ["direct_file"]
  }
}

filter {
  # Parse JSON logs
  if [message] =~ /^\{/ {
    json {
      source => "message"
    }
  }

  # Extract security events
  if [message] =~ /\[SECURITY\]/ {
    grok {
      match => { 
        "message" => "\[SECURITY\] %{WORD:event_type} - User: %{WORD:user_hash} - IP: %{IP:client_ip} - %{GREEDYDATA:event_details}"
      }
    }
    
    mutate {
      add_field => { "log_type" => "security" }
      add_field => { "severity" => "high" }
    }

    # Classify event severity
    if [event_type] in ["ACCOUNT_LOCKED", "SUSPICIOUS_ACTIVITY", "RATE_LIMIT_EXCEEDED"] {
      mutate {
        update => { "severity" => "critical" }
      }
    } else if [event_type] in ["AUTH_FAILURE", "LOGIN_INVALID_PASSWORD", "PASSWORD_RESET_INVALID_TOKEN"] {
      mutate {
        update => { "severity" => "medium" }
      }
    } else if [event_type] in ["AUTH_SUCCESS", "LOGIN_SUCCESS", "REGISTRATION"] {
      mutate {
        update => { "severity" => "low" }
      }
    }
  }

  # Add timestamp
  date {
    match => [ "timestamp", "ISO8601" ]
  }

  # GeoIP enrichment for IP addresses
  if [client_ip] {
    geoip {
      source => "client_ip"
      target => "geoip"
    }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "auth-starter-logs-%{+yyyy.MM.dd}"
  }
  
  # Debug output (remove in production)
  stdout {
    codec => rubydebug
  }
}